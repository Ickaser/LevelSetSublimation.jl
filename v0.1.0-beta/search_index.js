var documenterSearchIndex = {"docs":
[{"location":"disc/#All-Functions-with-Hard-coded-Discretizations","page":"Discretizations","title":"All Functions with Hard-coded Discretizations","text":"","category":"section"},{"location":"disc/#Heat-and-Mass-Transfer-Equations","page":"Discretizations","title":"Heat and Mass Transfer Equations","text":"","category":"section"},{"location":"disc/","page":"Discretizations","title":"Discretizations","text":"solve_T\nUsing 2nd order central differences, with linear extrapolation for ghost fluid cells.\nManually constructs sparse matrix, then solves it.\nUses a 2nd-order discretization with linear extrapolation as defined in (Gibou and Fedkiw, 2005), section 2\nsolve_p","category":"page"},{"location":"disc/#Velocity-Calculations","page":"Discretizations","title":"Velocity Calculations","text":"","category":"section"},{"location":"disc/","page":"Discretizations","title":"Discretizations","text":"compute_frontvel_heat\nComputes heat flux on Stefan interface\nUses 2nd-order finite difference with quadratic ghost cell extrapolation across Stefan interface to compute heat flux\nAdapted from techniques explained in (Gibou and Fedkiw, 2005)\nGenerates a velocity field for level set advection, defined only on dry-layer side of interface; follow with extrap_v_fastmarch to extrapolate throughout domain\ncompute_frontvel_mass\nComputes heat flux on Stefan interface\nUses 2nd-order finite difference with quadratic ghost cell extrapolation across Stefan interface to compute heat flux\nAdapted from techniques explained in (Gibou and Fedkiw, 2005)\nGenerates a velocity field for level set advection, defined only on dry-layer side of interface; follow with extrap_v_fastmarch to extrapolate throughout domain\ncompute_frontvel_fixedspeed\nUsed for generating arbitrary velocity fields–meant only for debugging\nIntended for use with velocity extrapolation; not currently implemented anywhere. \n1st order finite difference from interface cell into dried domain","category":"page"},{"location":"disc/#Velocity-Extrapolation","page":"Discretizations","title":"Velocity Extrapolation","text":"","category":"section"},{"location":"disc/","page":"Discretizations","title":"Discretizations","text":"extrap_v_fastmarch!\nUses 2nd-order upwind differences (towards the interface) in a fast-marching technique (which makes a single pass over all grid cells in sorted order) to extrapolate velocity away from the interface.\nFollows (Sethian, 1999), section 5.1","category":"page"},{"location":"disc/#Reinitialization","page":"Discretizations","title":"Reinitialization","text":"","category":"section"},{"location":"disc/","page":"Discretizations","title":"Discretizations","text":"reinitialize_ϕ_HCR!\nReinitializes using a by-hand Explicit Euler in time and WENO in space, as described in (Hartmann et al., 2010)","category":"page"},{"location":"disc/#WENO-Derivatives","page":"Discretizations","title":"WENO Derivatives","text":"","category":"section"},{"location":"disc/","page":"Discretizations","title":"Discretizations","text":"wenodiffs_local\nEvaluates a single WENO derivative\nImplemented as described in (Hartmann et al., 2009), \ndϕdx_all_WENO\nUsed in 𝒢_weno and therefore reinitialize_ϕ_HCR!\nAlso used in all velocity computation functions\n𝒢_weno , wrapped by 𝒢_weno_all\nUsed in reinitialize_ϕ_HCR!\nGodunov's scheme for the norm of gradient, using WENO derivatives","category":"page"},{"location":"alldocs/#Unfiltered-List-of-All-Documented-Functions","page":"All Docstrings","title":"Unfiltered List of All Documented Functions","text":"","category":"section"},{"location":"alldocs/#LevelSetSublimation.base_props-alldocs","page":"All Docstrings","title":"LevelSetSublimation.base_props","text":"An instance of PhysicalProperties with default values.\n\n\n\n\n\n","category":"constant"},{"location":"alldocs/#LevelSetSublimation.Domain-alldocs","page":"All Docstrings","title":"LevelSetSublimation.Domain","text":"Stores information on the grid and domain size for simulation.\n\nConstructors:  \n\nDomain(config::Dict) \nDomain(config::NamedTuple) \nDomain(nr, nz, rmax, zmax) \nDomain(nr, nz, rmax, zmax, bwfrac)\nDomain(nr, nz, rmin, rmax, zmin, zmax)\nDomain(nr, nz, rmin, rmax, zmin, zmax, bwfrac)\n\nIf not given, rmin and zmin default to 0.0, while bwfrac defaults to 0.2. Note that nr, nz, bwr, and bwz are assumed to be integers, while rmin, rmax, zmin, and zmax are assumed to be floats\n\nAll Fields: (given for 𝑟, likewise named for 𝑧)\n\nnr - number of grid points in 𝑟\nrmin, rmax - range of domain in 𝑟\nbwfrac - fraction of domain included in band around interface\nrgrid - vector of locations of grid points in 𝑟\ndr - grid spacing in 𝑟\ndr1 - 1/dr\ndr2 - 1/dr^2\nbwr - =ceil(Int, bwfrac*nr) integer width of band around interface in  which level set is treated\nntot - total number of grid points = nr*nz\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.LD-alldocs","page":"All Docstrings","title":"LevelSetSublimation.LD","text":"LD{T}\n\nA \"little difference\", to make Godunov's scheme in 𝒢_weno easier to read. For a = LD(x::T), \n\na.p = max(x, 0.0)\na.m = min(x, 0.0)\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.LevelSet-alldocs","page":"All Docstrings","title":"LevelSetSublimation.LevelSet","text":"LevelSet(phi, dom::Domain)\n\nA small struct, used in dispatch for plotting.\n\nThe plot recipe can be variously called as:\n\nplot(LevelSet(phi, dom), reflect=true)\nplot(LevelSet(phi, dom), reflect=false)\nplot!(LevelSet(phi, dom), reflect=true)\nplot!(LevelSet(phi, dom), reflect=false)\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.PhysicalProperties-alldocs","page":"All Docstrings","title":"LevelSetSublimation.PhysicalProperties","text":"An immutable type for representing a slate of physical properties and constants needed.\n\nA default constructor is provided which uses all defaults (borosilicate glass, water, ice), but thanks to Parameters.jl you can call with just values that need to be changed, e.g.\n\nPhysicalProperties() # all defaults\nPhysicalProperties(ρ_vw = 1u\"kg/m^3\", cp_vw = 1u\"J/kg/K\", εpp_vw = 1e-1) # adjust vial wall properties\n\nAll properties stored here are:\n\nρ_vw: Density of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.ρ_gl\ncp_vw: Heat capacity of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.cp_gl\nεpp_vw: Dielectric loss coefficient of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.εpp_gl\nρf: Density of frozen material (taken as water ice). Default: ρ_ice\nCpf: Heat capacity of frozen material (taken as water ice). Default: cp_ice\nkf: Thermal conductivity of frozen material. Default: LevelSetSublimation.kf\nMw: Molecular weight of sublimating species (defaults to water). Default: 0.018 * u\"kg/mol\"\nμ: Gas phase viscosity (in rarefied regime) of sublimating species (defaults to water). Default: LevelSetSublimation.μ\nΔH: Heat of sublimation of sublimating species (defaults to water); give as positive number. Default: LevelSetSublimation.ΔH\nεppf: Dielectric loss coefficient of frozen layer (defaults to water ice). Default: LyoPronto.εppf\nεpp_d: Dielectric loss coefficient of dry layer (defaults to 0). Default: 0.0\nR: Universal gas constant. Kept as a constant so that it gets nondimensionalized with the rest. Default: u\"R\"\nϵ0: Vacuum permittivity. Kept as a constant so that it gets nondimensionalized with the rest. Default: u\"ϵ0\" |> u\"F/m\"\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.TimeConstantProperties-alldocs","page":"All Docstrings","title":"LevelSetSublimation.TimeConstantProperties","text":"TimeConstantProperties(ϵ, l, κ, Rp0, kd, Kvwf, m_v, A_v, B_d, B_f, B_vw)\n\nA struct for holding physical properties which are likely to change from case to case.\n\nNo default constructor is provided by intention–all of these parameters should be at least considered before running a simulation.\n\nϵ\nl\nκ\nRp0\nkd\nKvwf\nm_v\nA_v\nB_d\nB_f\nB_vw\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.TimeVaryingProperties-alldocs","page":"All Docstrings","title":"LevelSetSublimation.TimeVaryingProperties","text":"TimeVaryingProperties(f_RF, P_per_vial, Tsh, pch, Kshf)\n\nA struct for holding controlled parameters that may change over time.\n\nTo get the value of all those parameters at a given time, call the struct  with a time, and it will evaluate each field at that time and provide a TimeVaryingPropertiesSnapshot. \n\nNo default constructor is provided by intention–all of these parameters should be at least considered before running a simulation.\n\nEach should be passed as a callable, which returns the value of the parameter as a function of time, with the exception of Kshf which is a function of pressure. See the RampedVariable and RpFormFit types from LyoPronto, which are intended to make this more convenient.\n\nf_RF\nP_per_vial\nTsh\npch\nKshf\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.TimeVaryingPropertiesSnapshot-alldocs","page":"All Docstrings","title":"LevelSetSublimation.TimeVaryingPropertiesSnapshot","text":"TimeVaryingPropertiesSnapshot(f_RF, P_per_vial, Tsh, pch, Kshf)\n\nA struct for holding a snapshot of the controlled parameters that may change over time.\n\nThis is meant to be constructed by calling an instance of the TimeVaryingProperties type.\n\nf_RF\nP_per_vial\nTsh\npch\nKshf\n\n\n\n\n\n","category":"type"},{"location":"alldocs/#LevelSetSublimation.arrows-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.arrows","text":"arrows(Vf, dom::Domain)\n\nAdd \"quiver\" to current plot, with velocity field Vf of shape (nx, ny, 2).\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_H0-NTuple{6, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_H0","text":"calc_H0(ϕ0, ϕ1, ϕ2, P0, P1, P2)\n\nImplementation of Min & Gibou 2008, Table 1.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_Tf_res-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_Tf_res","text":"calc_Tf_res(t, sim)\n\n\nGet Tf at a given time point, regardless of simulation's time integration. \n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_fillvol-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_fillvol","text":"calc_fillvol(dom)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_params_at_t-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_params_at_t","text":"calc_params_at_t(t, config)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_psub_highorder-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_psub_highorder","text":"calc_psub_highorder(T)\n\nCompute pressure (in Pascals) of sublimation at temperature T in Kelvin\n\nFrom Feistel and Wagner, 2006\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_rij_Sij-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_rij_Sij","text":"calc_rij_Sij(ϕ, Γ, C, dom::Domain)\n\nCompute rij, neighbors Sij for each cell in Γ.\n\nImplementation of eq. 19b from Hartmann 2010, scheme HCR-2\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_uTfTp_res-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_uTfTp_res","text":"calc_uTfTp_res(t, sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.calc_δ0-NTuple{6, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.calc_δ0","text":"calc_δ0(ϕ0, ϕ1, ϕ2, P0, P1, P2)\n\nImplementation of Min & Gibou 2008, Table 1.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compare_lyopronto_res-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compare_lyopronto_res","text":"compare_lyopronto_res(ts, sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compare_lyopronto_res-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compare_lyopronto_res","text":"compare_lyopronto_res(sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_Qice-Tuple{Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_Qice","text":"function compute_Qice(ϕ, T, p, dom::Domain, params)\n\nCompute the total heat input into frozen & dried domains. Also passes glass-ice heat as separate return.\n\nSee p. 112-113 from paperlike notes. At pseudosteady conditions, all heat getting added to the system goes to the frozen domain, so we don't actually need to treat different areas of the surface. In addition, the sublimation flux is simply evaluated at the top cake surface.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_Qice_nodry-Tuple{Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_Qice_nodry","text":"compute_Qice_nodry(u, T, dom::Domain, params)\n\nCompute the total heat input into frozen domain from volumetric, shelf, and glass.  Contrast with compute_Qice_noflow and compute_Qice, which include heat to dried domain.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_Qice_noflow-Tuple{Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_Qice_noflow","text":"compute_Qice_noflow(u, T, dom::Domain, params)\n\nCompute the total heat input into frozen & dried domains, assuming mass flow is zero. Also passes glass-ice heat as separate return.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_Tderiv-Tuple{Any, Any, Any, Int64, Int64, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_Tderiv","text":"compute_Tderiv(u, T, ir::Int, iz::Int, dom::Domain, params)\n\nCompute (∂T/∂r, ∂T/∂z) at point (ir, iz), given system state u, T.\n\nQuadratic ghost cell extrapolation (into frozen domain), second order finite differences, for T.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_discrete_H-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_discrete_H","text":"compute_discrete_H(ϕ, dom)\n\nCompute the discrete Heaviside H across the domain, for use in volume integrals. \n\nImplements the discrete Heaviside of Min & Gibou, 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_discrete_δ-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_discrete_δ","text":"compute_discrete_δ(ϕ, dom)\n\nCompute the discrete Dirac δ throughout the domain, for use in surface integrals.  Implements the discrete delta of Min and Gibou 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_frontvel_fixedspeed-Tuple{Any, Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_frontvel_fixedspeed","text":"compute_frontvel_fixedspeed(v0, ϕ, dom::Domain)\n\nCompute speed v0 times normal vector on Γ⁺, positive side of interface.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_frontvel_heat-Tuple{Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_frontvel_heat","text":"compute_frontvel_heat(u, T, p, dom::Domain, params; debug=false)\n\nGenerate an empty velocity field and compute velocity on Γ⁺ (i.e. cells on Γ with ϕ>0). \n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_frontvel_mass-Tuple{Any, Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_frontvel_mass","text":"compute_frontvel_mass(ϕ, Tf, T, p, dom::Domain, params; debug=false)\n\nGenerate an empty velocity field and compute velocity on Γ⁺ (i.e. cells on Γ with ϕ>0). \n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_icegl_area-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_icegl_area","text":"compute_icegl_area(ϕ, dom::Domain)\n\nCompute area of where ice meets radial outer surface of vial.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_iceht_bottopcont-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_iceht_bottopcont","text":"function compute_iceht_bottopcont(ϕ, dom)\n\nCompute the height of ice at each point radially, as well as identify whether it touches system boundary or not.\n\nReturns (heights, bottom_contact, top_contact), where \n\nheights is a vector of floats\nbottom_contact, top_contact are vectors of bools\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_icesh_area-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_icesh_area","text":"compute_icesh_area(ϕ, dom::Domain)\n\nCompute area of where ice meets bottom surface of vial.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_icesurf_δ-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_icesurf_δ","text":"compute_icesurf_δ(ϕ, dom)\n\nCompute the surface area of the ice, using a discrete Dirac delta function. Calls compute_discrete_δ, which is implemented according to Min and Gibou 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_icevol_H-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_icevol_H","text":"compute_icevol_H(ϕ, dom)\n\nCompute the volume of the ice, using a discrete Heaviside function. Calls compute_discrete_H, which is implemented according to Min and Gibou 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_local_H-Tuple{CartesianIndex, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_local_H","text":"compute_local_H(ij::CartesianIndex, ϕ, dom)\n\nReturn the discrete Heaviside for level set ϕ at location ij.\n\nImplementation of the final expression for a discrete Heaviside in Min & Gibou, 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_local_δ-Tuple{CartesianIndex, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_local_δ","text":"compute_local_δ(ij::CartesianIndex, ϕ, dom)\n\nReturn the discrete delta for level set ϕ at location ij.\n\nImplementation of the final expression for a discrete delta in Min and Gibou 2008.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_pderiv-Tuple{Any, Any, Any, Any, Int64, Int64, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_pderiv","text":"compute_pderiv(u, T, p, ir::Int, iz::Int, dom::Domain, params)\n\nCompute  ∂p/∂r, ∂p/∂z at point (ir, iz), given system state u, T, p.\n\nQuadratic ghost cell extrapolation (into frozen domain), second order finite differences, for p.\n\nThe distinction in discretization between this and compute_Tderiv is essentially just the boundary treatments.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.compute_topmassflux-Tuple{Any, Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.compute_topmassflux","text":"compute_topmassflux(ϕ, T, p, dom::Domain, params)\n\nCompute total mass flow through top of the cake (that is, mass flux integrated across top surface).\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.cond_end-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.cond_end","text":"cond_end(u, t, integ)\n\nChanges from positive to negative when the minimum value of ϕ is   within min(dom.dz, dom.dr)/4, which is when drying is essentially complete.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatmass!-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatmass!","text":"dudt_heatmass!(du, u, p, t)\n\nEvaluate local time rate of change for u and put results in du.\n\nSplitting u and du into ϕ, Tf, and Tvw is handled by ϕ_T_from_u and ϕ_T_from_u_view.\n\nParameters p assumed to be (dom::Domain, params) This is a right-hand-side for ∂ₜϕ = -v⋅∇ϕ, where v = (vr, vz) is evaluated by computing and extrapolating front velocity using compute_frontvel_mass.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatmass-Tuple{Any, Domain, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatmass","text":"dudt_heatmass(u, dom::Domain, params, t)\ndudt_heatmass(u, config::Dict, t=0.0)\n\nCompute the time derivative of u with given (nondimensional) parameters.\n\nWraps a call on dudt_heatmass!, for convenience in debugging and elsewhere that efficiency is less important\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatmass_dae!-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatmass_dae!","text":"doc\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatmass_implicit!-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatmass_implicit!","text":"doc\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatmass_params-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatmass_params","text":"dudt_heatmass_params(u, config)\n\nCompute the time derivative of u with given parameters, and also return dom and params associated with the given config.\n\nWraps a call on dudt_heatmass, for convenience in debugging and elsewhere that efficiency is less important\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatonly!-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatonly!","text":"dudt_heatonly!(du, u, p, t)\n\nEvaluate local time rate of change for u and put results in du.\n\nThis function leaves Tf and Tvw untouched, since there isn't a way to govern their dynamics without mass transfer.\n\nu and du are both structured according to \n\nThis is a right-hand-side for ∂ₜϕ = -v⋅∇ϕ, where v = (vr, vz) is evaluated by computing and extrapolating front velocity using compute_frontvel_mass.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dudt_heatonly-Tuple{Any, Domain, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dudt_heatonly","text":"dudt_heatonly(u, dom::Domain, params)\ndudt_heatonly(u, config)\n\nCompute the time derivative of u with given parameters.\n\nWraps a call on dudt_heatonly!, for convenience in debugging and elsewhere that efficiency is less important\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dϕdx_all_WENO-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dϕdx_all_WENO","text":"dϕdx_all_WENO(ϕ, dom)\n\nCompute (∂ϕ/∂r west, ∂ϕ/∂r east, ∂ϕ/∂z south, ∂ϕ/∂z north) using WENO derivatives.\n\nImplemented by computing WENO derivatives for each cell separately, which is a little wasteful. Beyond the boundaries of domain, ϕ is extrapolated according to get_or_extrapolate_ϕ.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.dϕdx_all_WENO_loc-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.dϕdx_all_WENO_loc","text":"dϕdx_all_WENO_loc(ϕ, dom)\n\nCompute (∂ϕ/∂r west, ∂ϕ/∂r east, ∂ϕ/∂z south, ∂ϕ/∂z north) using WENO derivatives.\n\nImplemented by computing WENO derivatives for each cell separately, which is a little wasteful. Beyond the boundaries of domain, ϕ is extrapolated according to get_or_extrapolate_ϕ.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.eval_b-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.eval_b","text":"eval_b(T, p, params)\n\nCompute transport coefficient b as a function of space, given T, p, and params.\n\nparams should have the following fields: l, κ, R, Mw, μ.  l, and κ may be passed as scalars (and assumed as spatially uniform) or arrays (describing value throughout space, should match Domain dimensions).\n\nWhen the simulation is started, all these values are converted to SI units and passed accordingly,  so in practice there are no units to track.\n\nIf κ=0, no spatial variation due to pressure occurs.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.eval_b_loc-NTuple{5, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.eval_b_loc","text":"eval_b_loc(T, p, ir, iz, params)\n\nLocally evaluate transport coefficient (indexes into spatially varying l and κ if necessary).\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.extrap_v_fastmarch!-Tuple{Any, Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.extrap_v_fastmarch!","text":"extrap_v_fastmarch(v_front, u, dom::Domain)\n\nCompute an extrapolated velocity field in place. v_front should be nonzero only on Γ⁺, positive side of interface.\n\nUsing fast marching, instead of the PDE-based approach, to get second order accuracy more easily.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.fastmarch_v!-Tuple{Any, Any, Vector{CartesianIndex{2}}, Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.fastmarch_v!","text":"fastmarch_v!(vf, acc, locs, ϕ, dom)\n\nMutate vf and acc to extrapolate vf from interface by fast marching.\n\nCells are calculated in order of increasing |ϕ|. Uses matrix of bools acc (denoting accepted cells) to determine cells to use in extrapolation, so if you determine one side first, will get used in the derivatives for the other side.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.freshplot-Tuple{Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.freshplot","text":"freshplot(dom::Domain)\n\nGenerate an empty plot, scaled to show only dom.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.gen_anim-alldocs","page":"All Docstrings","title":"LevelSetSublimation.gen_anim","text":"gen_anim(config)\ngen_anim(config, var)\ngen_anim(config, var, casename)\n\n\n\n\n\n\n","category":"function"},{"location":"alldocs/#LevelSetSublimation.gen_sumplot-alldocs","page":"All Docstrings","title":"LevelSetSublimation.gen_sumplot","text":"gen_sumplot(config)\ngen_sumplot(config, var)\ngen_sumplot(config, var, casename)\n\n\n\n\n\n\n","category":"function"},{"location":"alldocs/#LevelSetSublimation.get_SA-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_SA","text":"get_SA(res)\n\n\nCompute surface area over time for the given simulaiton results.\n\nReturns (ts, SA_t)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_eff_Rp-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_eff_Rp","text":"get_eff_Rp(sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_or_extrapolate_ϕ-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_or_extrapolate_ϕ","text":"get_or_extrapolate_ϕ(ϕ, ind, stencil)\n\nEither retrieve ϕ at ind on the given stencil, or extrapolate and return domain + extrapolated values.\n\nThis extrapolation is on a uniform grid, using a quadratic extrapolant. Define Lagrange interpolant with last three points in domain, then  extrapolate outside the domain to make ghost points. Ghost points are then a linear combination of points from domain. A matrix form just keeps this compact and efficient; extrap_ϕ_mat in the source is just the matrix representing this extrapolation.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_subf_r-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_subf_r","text":"get_subf_r(ϕ, dom)\n\n\nCompute the average 𝓇 position of the sublimation front.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_subf_z-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_subf_z","text":"get_subf_z(ϕ, dom)\n\n\nCompute the average 𝑧 position of the sublimation front.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_t_Tf-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_t_Tf","text":"get_t_Tf(sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.get_t_Tf_subflux-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.get_t_Tf_subflux","text":"get_t_Tf_subflux(sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.heat-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.heat","text":"heat(field, dom::Domain)\n\nReturn a heatmap of field, scaled to fit on dom.\n\nThis function generates a new plot.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.identify_B-Tuple{Vector{CartesianIndex{2}}, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.identify_B","text":"identify_B(Γc::Vector{CartesianIndex{2}}, dom::Domain; extra=0)\nidentify_B(Γ_field::Matrix{Bool}, dom::Domain)\nidentify_B(ϕ::Matrix{Float64}, dom::Domain)\nidentify_B(ϕ::Any, dom::Domain)\n\nReturn a field of bools identifying the band around the interface.\n\nThe width in the band around Γ is specified by the fields bwr and bwz,  which represent number of cells in the 𝑟 and 𝑧 directions respectively. extra will tack on extra cells, if in some (but not all) places you need a larger band than the default.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.identify_Γ-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.identify_Γ","text":"function identify_Γ(ϕ, dom::Domain)\n\nIdentify cells on the sublimation front (interface), returning as a Matrix::Bool.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.interp_saved_Tf-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.interp_saved_Tf","text":"interp_saved_Tf(saved_Tf)\n\n\nInterpolate a set of SavedValues of Tf. Useful so that I use the same interpolation everywhere it shows up.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.make_M1_properties-Tuple{}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.make_M1_properties","text":"make_M1_properties()\n\nReturns physical parameters for the mannitol experimental case which was used to originally develop and validate this model.\n\nUseful for testing.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.make_u0_ndim-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.make_u0_ndim","text":"make_u0_ndim(init_prof, Tf0, Tvw0, dom)\n\nSet up a vector of dynamic variables as initial state for simulation.\n\nStructure of vector u: ComponenentArray with fields ϕ, Tf, and Tvw. ϕ is a 2D array of the same size as the domain, Tf is a 1D array of size dom.nr, and  Tvw is a scalar.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.make_ϕ0-Tuple{Symbol, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.make_ϕ0","text":"make_ϕ0(ϕtype::Symbol, dom::Domain; ϵ=1e-4)\n\nReturn a ϕ0 with appropriate size for the passed Domain.\n\nParameter ϵ * sqrt(dom.rmax*dom.zmax) is added to ensure that interface is within domain. Currently allowed setups:\n\n:top, :flat – interface at zmax*(1 - ϵ)\n:rad, :cyl  – interface at rmax*(1 - ϵ)\n:box          – interface at both zmax(1-ϵ) and rmax(1-ϵ)\n:cone         – interface a line decreasing in r\n:midflat      – interface at zmax*0.5\n:ell_bub     – ellipse in center of vial, separated from boundaries\n:circ        – circle at r=0, z=0 \n:tinycirc    – circle at r=0, z=0, very small radius\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.markcells-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.markcells","text":"markcells(cells, dom::Domain; lab=\"\", c=:white)\n\nAdd a star marker for each CartesianIndex in  cells to the current plot.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.markfront-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.markfront","text":"markfront(phi, dom::Domain; lab=\"\", c=:white)\n\nAdd a star marker to Γ (front) cells based on ϕ for current plot, in mutating fashion.\n\nInternally calls Γ_cells.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.params_nondim_setup-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.params_nondim_setup","text":"params_nondim_setup(params_dim)\nparams_nondim_setup(base_d, tcp_d, tvp_d)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.plot_cylheat-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.plot_cylheat","text":"plot_cylheat(T, dom::Domain)\n\nIn a mutating fashion, add a \"cylindrical\" heatmap of T to the current plot. (\"Cylindrical\" meaning reflected across x=0 axis.)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.plot_frontvel-Tuple{Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.plot_frontvel","text":"function plot_frontvel(ϕ, T, dom::Domain)\n\nCalculate, then plot the front velocity given ϕ and T.\n\nMeant for debugging, mostly. Scales all velocity arrows to have length 0.5. Generates a freshplot().\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.plotframe-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.plotframe","text":"plotframe(t::Float64, sim; maxT=nothing, heatvar=:T)\n\nUnpack simulation results and plot the state at time t.\n\nheatvar = :T or =:ϕ or =:p decides whether temperature, level set function, or pressure is plotted as colors. If given, maxT sets an upper limit for the associated colorbar.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.reinit_wrap-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.reinit_wrap","text":"reinit_wrap(integ)\n\nThin wrapper to reinitialize the state of the level set function.\n\nUses a tolerance of 0.02 for error in norm of gradient (which should be 1)  in the region B (band around the interface). If verbose=true, logs the error in signed distance function before and after reinit, as well as current dried fraction\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.reinitialize_ϕ_HCR!-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.reinitialize_ϕ_HCR!","text":"reinitialize_ϕ_HCR!(ϕ, dom::Domain; maxsteps = 50, tol=1e-4, err_reg=:B)\n\nReinitialize ϕ throughout the domain.\n\nImplementation of Eq. 22 in Hartmann 2010, scheme HCR-2.\n\nChecks L∞ error (of |∇ϕ|=1) against tol either in band around interface  (err_reg=:B) or throughout domain (err_reg=:all), and ends iteration  early if tolerance is met.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.reinitialize_ϕ_HCR-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.reinitialize_ϕ_HCR","text":"reinitialize_ϕ_HCR(ϕ, dom::Domain)\n\nThin wrapper on reinitialize_ϕ_HCR! to avoid mutating.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.reinitialize_ϕ_HCR_blindspots!-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.reinitialize_ϕ_HCR_blindspots!","text":"reinitialize_ϕ_HCR_blindspots!(ϕ, dom::Domain; maxsteps = 50, tol=1e-4, err_reg=:B)\n\nReinitialize ϕ throughout the domain.\n\nImplementation of Eq. 22 in Hartmann 2010, scheme HCR-2. Augmented by (Della Rocca and Blanquart, 2014)'s treatment of contact line blind spots.\n\nChecks L∞ error (of |∇ϕ|=1) against tol either in band around interface  (err_reg=:B) or throughout domain (err_reg=:all), and ends iteration  early if tolerance is met.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.reinitialize_ϕ_HCR_blindspots-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.reinitialize_ϕ_HCR_blindspots","text":"reinitialize_ϕ_HCR(ϕ, dom::Domain)\n\nThin wrapper on reinitialize_ϕ_HCR! to avoid mutating.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.resultsanim-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.resultsanim","text":"resultsanim(sim, casename; seconds_length=5, heatvar=:T)\n\nGenerate a .gif of the given sim, with filename casename_heatvar_evol.gif.\n\nPass either :p or :T as heatvar. Passing ϕ will probably cause filename problems\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.sdf_err_L1-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.sdf_err_L1","text":"sdf_err_L1(ϕ, dom; region=:B)\n\nCompute the L1 norm of the error in the Eikonal equation  |∇ϕ| = 1, on the given region (either :B or :all).\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.sdf_err_L∞-Tuple{Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.sdf_err_L∞","text":"sdf_err_L∞(ϕ, dom; region=:B)\n\nCompute the L∞ norm of the error in the Eikonal equation  |∇ϕ| = 1, on the given region (either :B or :all).\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.sim_from_dict-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.sim_from_dict","text":"sim_from_dict(config; tf=1e5, verbose=false)\n\nGiven a simulation configuration config, run a simulation.\n\nMaximum simulation time (not CPU time, but simulation time) is specified by tf, which is in seconds; 1e5 is 270 hours. (No matter how much ice is left at that point, simulation will end.) verbose=true will put out some info messages about simulation progress, i.e. at each reinitialization.\n\nAll passed parameters should have Unitful unit annotations, so they can be in whatever units are convenient; inside this function, they will be converted to SI marks then have units stripped off (for easier numerical implementation). The results will be in SI units, so times in seconds, temperature in Kelvin, pressure in Pa, etc. Employ Unitful to do unit conversions after simulation if necessary.\n\nconfig must have the following fields:\n\nfillvol, fill volume with Unitful units (e.g. 3u\"mL\")\nvialsize, a string (e.g. \"2R\") giving vial size\nparamsd, a Tuple{PhysicalProperties, TimeConstantProperties, TimeVaryingProperties}    (i.e. a tuple of the three objects). See PhysicalProperties, TimeConstantProperties, TimeVaryingProperties.\n\nThe following fields have default values and are therefore optional:\n\nsimgridsize, a tuple giving number of grid points to use for simulation. Defaults to (51, 51).\nTf0, an initial ice temperature. Defaults to Tsh(0) if not provided  \nTvw0, an initial glass temperature. Defaults to Tf0.\ntime_integ: defaults to Val(:exp_newton); other options are Val(:dae), Val(:dae_then_exp) and Val(:ode_implicit).   Among these three, slightly different problem formulations are used (explicit ODE with internal Newton solve, DAE, and implicit ODE).\ninit_prof, a Symbol indicating a starting profile (from make_ϕ0)\n\nThe three problem formulations have different advantages; in my testing, the DAE formulation and implicit formulation tend to run faster and more closely reflect the problem structure, but they run into instabilities when the sublimation front peels away from the wall, whereas the explicit ODE formulation can jump over that point.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.sim_from_u0-Tuple{Any, Any, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.sim_from_u0","text":"sim_from_u0(u0, t0, config; tf=1e6, verbose=false)\n\nWrapped by sim_from_dict; useful on its own if you want to start from partway through a simulation.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.sim_heatonly-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.sim_heatonly","text":"sim_heatonly(config; tf=1e5, verbose=false)\n\nGiven a simulation configuration config, run a simulation.\n\nThis simulation is stripped-down: no mass transfer, no variation in ice & glass temperature\n\nMaximum simulation time is specified by tf. verbose=true will put out some info messages about simulation progress, i.e. at each reinitialization.\n\nCURRENTLY OUT OF DATE with parameter input structures.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.solve_T-Tuple{Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.solve_T","text":"solve_T(u, Tf, dom::Domain, params)\n\nCompute 2D axisymmetric T profile, returning ghost cell values, for given state u and Tf.\n\nNeumann boundary conditions on all rectangular boundaries; Dirichlet on zero-level set.\n\nThis implementation uses second-order finite differences, with linear extrapolation into Ω⁻.   Coefficients are all hard-coded here, unfortunately. (For more on extrapolation, see Gibou et al., 2002, \"Second-Order-Accurate ... Poisson ... \")   Neumann boundaries use a ghost point & BC to define ghost cell, then use same stencil as normal. Coefficients computed in gfm_extrap.ipynb, using Sympy.   (For higher order, see Gibou and Fedkiw, 2005, \"A fourth order accurate discretization ... Laplace ... \")  \n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.solve_p-Tuple{Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.solve_p","text":"solve_p(u, T, dom::Domain, params[, p0]; maxit=20, reltol=1e-6) where G<:AbstractArray\n\nIteratively compute the pressure profile for system state u, Tf, and T.\n\nThere is a weak nonlinearity in the system, since the mass transfer coefficient b depends partially on pressure. To treat this, use a guessed pressure p0 (which, if not provided, is set everywhere to chamber pressure) to compute b, then perform a linear solve for p using solve_p_given_b. At this point, recompute b, then recompute p.\n\nIn preliminary testing, this usually converges within 5 or 10 iterations. Usually if it doesn't converge, it is because temperatures are outside the expected range, yielding crazy sublimation pressures. (Occasionally it means I incorrectly wrote a finite difference somewhere.)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.solve_p_given_b-Tuple{Any, Any, Any, Domain, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.solve_p_given_b","text":"solve_p_given_b(ϕ, b, Tf, dom::Domain, params)\n\nCompute 2D axisymmetric pseudosteady pressure profile for given values of level set function ϕ, temperature T, and transport coefficient b.\n\nb is a dusty-gas transport coefficient for the pressure, which can vary spatially. Homogeneous Neumann boundary conditions at r=0, r=R, z=0; Dirichlet on zero-level set (p=p_sub), Robin at top (dp/dz = (pch-p)/Rp0). params should have fields: \n\nRp0 : zero-thickness resistance offset, often written R0 in lyo literature\npch : chamber (or vial) pressure at top surface\n\nThis implementation uses second-order finite differences, with linear extrapolation into Ω⁻.   (For details, see (Gibou and Fedkiw, 2005).)   Coefficients are all hard-coded here, unfortunately. Neumann boundaries use a ghost point & BC to define ghost cell, then use same stencil as normal. Coefficients computed in gfm_extrap.ipynb, using Sympy.  \n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.summaryT-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.summaryT","text":"summaryT(sim; layout, clims, tstart, tend)\n\n\nPlot temperature fields at several time instants throughout the simulation.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.summaryplot-Tuple{Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.summaryplot","text":"summaryplot(sim; layout=(3,2), heatvar=:T)\n\nReturn a 2x3 plot of simulation results from start to finish.\n\nsim should have a field \"sol\" , which is passed to get_ϕ(sol, t, dom::Domain) .   heatvar determines what is plotted as a heatmap in the results (:T or :ϕ, currently.)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.virtual_thermocouple-Tuple{NamedTuple}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.virtual_thermocouple","text":"virtual_thermocouple(sim)\n\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.weno_Φ-NTuple{4, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.weno_Φ","text":"weno_Φ(c, d, e, f)\n\nReturn a weighted sum of finite differences for a WENO approximation.  Defined in §3.2 of (Hartmann et al., 2009) .\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.wenodiffs_local-NTuple{8, Any}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.wenodiffs_local","text":"wenodiffs_local(u_m3, u_m2, u_m1, u_0, u_p1, u_p2, u_p3, dx)\n\nCompute one-sided finite differences, using Jiang and Peng's WENO approximation (Jiang and Peng, 2000).\n\nA relatively easy-to-read reference is §3.2 of (Hartmann et al., 2009) .\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.Γ_cells-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.Γ_cells","text":"Γ_cells(ϕ, dom::Domain)\n\nCompute findall(identify_Γ(ϕ, dom)). (That's the whole implementation.)\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.𝒢_1st-Tuple{Any, Any, Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.𝒢_1st","text":"𝒢_1st(ϕ, i, j, dom::Domain)\n\nCompute the norm of the gradient of ϕ at point i, j by Godunov's scheme to first-order accuracy.\n\np. 6830 of Hartmann 2008, 10th page of PDF\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.𝒢_1st_all-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.𝒢_1st_all","text":"𝒢_1st_all(ϕ, dom::Domain)\n\nCompute the norm of the gradient of ϕ throughout domain by Godunov's scheme to first-order accuracy.\n\nInternally, calls 𝒢_1st on all computational cells.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.𝒢_weno-Tuple{Any, Int64, Int64, Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.𝒢_weno","text":"𝒢_weno(ϕ, ir::Int, iz::Int, dom::Domain)\n𝒢_weno(ϕ, ind::CartesianIndex{2}, dom::Domain)\n𝒢_weno(ϕ, ir::Int, iz::Int, ϕ0sign, dom::Domain)\n𝒢_weno(ϕ, ind::CartesianIndex{2}, ϕ0sign, dom::Domain)\n\nCompute the norm of the gradient by Godunov's scheme with WENO differences (wenodiffs_local).\n\nIf supplied, ϕ0sign is used in Godunov's scheme, rather than the current sign of ϕ. Described in (Hartmann et al., 2009), eq. 6 to eq. 9. Boundary treatment of ghost cells handled by get_or_extrapolate_ϕ.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.𝒢_weno_all-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.𝒢_weno_all","text":"𝒢_weno_all(ϕ, [dϕdx_all,] dom::Domain; signs=nothing)\n\nCompute the norm of the gradient of ϕ throughout domain by Godunov's scheme with WENO derivatives. If signs of ϕ should refer to some prior state, can be provided. If dϕdx_all is provided, then is not recomputed internally.\n\nInternally, calls 𝒢_weno on all computational cells.\n\n\n\n\n\n","category":"method"},{"location":"alldocs/#LevelSetSublimation.𝒢_weno_all_old-Tuple{Any, Domain}-alldocs","page":"All Docstrings","title":"LevelSetSublimation.𝒢_weno_all_old","text":"𝒢_weno_all_old(ϕ, dom::Domain)\n\nCompute the norm of the gradient of ϕ throughout domain by Godunov's scheme with WENO derivatives.\n\nInternally, calls 𝒢_weno on all computational cells.\n\n\n\n\n\n","category":"method"},{"location":"todo/#Backlog","page":"Backlog","title":"Backlog","text":"","category":"section"},{"location":"todo/","page":"Backlog","title":"Backlog","text":"Pull all level set geometry calculations into functions, write unit tests for all of those\nBuild in some doctests\nBegin building test suite for every function, especially the edge cases\nVelocity extrapolation\nGeometry functions\nDocs for new reinit behavior in simulation\nUnify error region across all methods\nUse Della Rocca and Blanquart, 2014 for reinitialization at boundaries\nBegin reinvestigating performance, see if there are any easy gains to be had\nExamine current caching behavior\nBuild a data dependency graph among functions, identify a better way to pass data around\nCompile linsolvetestingradial.jl, linsolvetestingvertical.jl and pseudosteadyTtesting.jl into coherent unit tests; figure out a good place to keep the nice plots I generated\n1D temperatures\n1D pressures\nPseudosteady Tf\nOther cases to consider testing\n2D temperature, no ice\nPurge the many unnecessary lines of commented code","category":"page"},{"location":"todo/#Next-TODO","page":"Backlog","title":"Next TODO","text":"","category":"section"},{"location":"todo/","page":"Backlog","title":"Backlog","text":"At boundaries, evaluate derivatives at interface instead of boundary (both T and p)","category":"page"},{"location":"plots/#Plotting-and-Accessing-Simulation-Results","page":"Visualizing Simulation Results","title":"Plotting and Accessing Simulation Results","text":"","category":"section"},{"location":"plots/#Visualizing-simulation-results","page":"Visualizing Simulation Results","title":"Visualizing simulation results","text":"","category":"section"},{"location":"plots/#LevelSetSublimation.summaryplot","page":"Visualizing Simulation Results","title":"LevelSetSublimation.summaryplot","text":"summaryplot(sim; layout=(3,2), heatvar=:T)\n\nReturn a 2x3 plot of simulation results from start to finish.\n\nsim should have a field \"sol\" , which is passed to get_ϕ(sol, t, dom::Domain) .   heatvar determines what is plotted as a heatmap in the results (:T or :ϕ, currently.)\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.resultsanim","page":"Visualizing Simulation Results","title":"LevelSetSublimation.resultsanim","text":"resultsanim(sim, casename; seconds_length=5, heatvar=:T)\n\nGenerate a .gif of the given sim, with filename casename_heatvar_evol.gif.\n\nPass either :p or :T as heatvar. Passing ϕ will probably cause filename problems\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.plotframe","page":"Visualizing Simulation Results","title":"LevelSetSublimation.plotframe","text":"plotframe(t::Float64, sim; maxT=nothing, heatvar=:T)\n\nUnpack simulation results and plot the state at time t.\n\nheatvar = :T or =:ϕ or =:p decides whether temperature, level set function, or pressure is plotted as colors. If given, maxT sets an upper limit for the associated colorbar.\n\n\n\n\n\n","category":"function"},{"location":"plots/#Accessing-simulation-results","page":"Visualizing Simulation Results","title":"Accessing simulation results","text":"","category":"section"},{"location":"plots/","page":"Visualizing Simulation Results","title":"Visualizing Simulation Results","text":"The return from sim_from_dict is a dictionary, with a field \"dom\" containing a Domain and \"sol\" containing an ODESolution.","category":"page"},{"location":"plots/","page":"Visualizing Simulation Results","title":"Visualizing Simulation Results","text":"The ODESolution type comes from DifferentialEquations, and comes with lots of convenience functions documented here.","category":"page"},{"location":"plots/","page":"Visualizing Simulation Results","title":"Visualizing Simulation Results","text":"At a particular timestep, u is used to describe the system's state.  With the current implementation, u is a vector, with nr*nz values of the level set function throughout the domain, followed by 1 value for frozen temperature Tf and one value for glass temperature Tvw. ϕ_T_from_u will return a tuple (ϕ, Tf, Tvw) ; this is just so you don't have to hard-code which indices are which variables.","category":"page"},{"location":"plots/#Fine-grained-plotting-functions,-used-internally","page":"Visualizing Simulation Results","title":"Fine-grained plotting functions, used internally","text":"","category":"section"},{"location":"plots/#LevelSetSublimation.plot_cylheat","page":"Visualizing Simulation Results","title":"LevelSetSublimation.plot_cylheat","text":"plot_cylheat(T, dom::Domain)\n\nIn a mutating fashion, add a \"cylindrical\" heatmap of T to the current plot. (\"Cylindrical\" meaning reflected across x=0 axis.)\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.freshplot","page":"Visualizing Simulation Results","title":"LevelSetSublimation.freshplot","text":"freshplot(dom::Domain)\n\nGenerate an empty plot, scaled to show only dom.\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.heat","page":"Visualizing Simulation Results","title":"LevelSetSublimation.heat","text":"heat(field, dom::Domain)\n\nReturn a heatmap of field, scaled to fit on dom.\n\nThis function generates a new plot.\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.LevelSet","page":"Visualizing Simulation Results","title":"LevelSetSublimation.LevelSet","text":"LevelSet(phi, dom::Domain)\n\nA small struct, used in dispatch for plotting.\n\nThe plot recipe can be variously called as:\n\nplot(LevelSet(phi, dom), reflect=true)\nplot(LevelSet(phi, dom), reflect=false)\nplot!(LevelSet(phi, dom), reflect=true)\nplot!(LevelSet(phi, dom), reflect=false)\n\n\n\n\n\n","category":"type"},{"location":"plots/#LevelSetSublimation.arrows","page":"Visualizing Simulation Results","title":"LevelSetSublimation.arrows","text":"arrows(Vf, dom::Domain)\n\nAdd \"quiver\" to current plot, with velocity field Vf of shape (nx, ny, 2).\n\n\n\n\n\n","category":"function"},{"location":"plots/#LevelSetSublimation.markfront","page":"Visualizing Simulation Results","title":"LevelSetSublimation.markfront","text":"markfront(phi, dom::Domain; lab=\"\", c=:white)\n\nAdd a star marker to Γ (front) cells based on ϕ for current plot, in mutating fashion.\n\nInternally calls Γ_cells.\n\n\n\n\n\n","category":"function"},{"location":"plots/","page":"Visualizing Simulation Results","title":"Visualizing Simulation Results","text":"plot(::LevelSet, reflect=true) plots the zero-level set for a level set function LevelSet(phi, dom::Domain). reflect reflects across the y-axis to make cylindrical plots.","category":"page"},{"location":"sim/#Running-a-Simulation-with-LevelSetSublimation","page":"Running a Simulation","title":"Running a Simulation with LevelSetSublimation","text":"","category":"section"},{"location":"sim/#Main-Simulation-Method","page":"Running a Simulation","title":"Main Simulation Method","text":"","category":"section"},{"location":"sim/#LevelSetSublimation.sim_from_dict","page":"Running a Simulation","title":"LevelSetSublimation.sim_from_dict","text":"sim_from_dict(config; tf=1e5, verbose=false)\n\nGiven a simulation configuration config, run a simulation.\n\nMaximum simulation time (not CPU time, but simulation time) is specified by tf, which is in seconds; 1e5 is 270 hours. (No matter how much ice is left at that point, simulation will end.) verbose=true will put out some info messages about simulation progress, i.e. at each reinitialization.\n\nAll passed parameters should have Unitful unit annotations, so they can be in whatever units are convenient; inside this function, they will be converted to SI marks then have units stripped off (for easier numerical implementation). The results will be in SI units, so times in seconds, temperature in Kelvin, pressure in Pa, etc. Employ Unitful to do unit conversions after simulation if necessary.\n\nconfig must have the following fields:\n\nfillvol, fill volume with Unitful units (e.g. 3u\"mL\")\nvialsize, a string (e.g. \"2R\") giving vial size\nparamsd, a Tuple{PhysicalProperties, TimeConstantProperties, TimeVaryingProperties}    (i.e. a tuple of the three objects). See PhysicalProperties, TimeConstantProperties, TimeVaryingProperties.\n\nThe following fields have default values and are therefore optional:\n\nsimgridsize, a tuple giving number of grid points to use for simulation. Defaults to (51, 51).\nTf0, an initial ice temperature. Defaults to Tsh(0) if not provided  \nTvw0, an initial glass temperature. Defaults to Tf0.\ntime_integ: defaults to Val(:exp_newton); other options are Val(:dae), Val(:dae_then_exp) and Val(:ode_implicit).   Among these three, slightly different problem formulations are used (explicit ODE with internal Newton solve, DAE, and implicit ODE).\ninit_prof, a Symbol indicating a starting profile (from make_ϕ0)\n\nThe three problem formulations have different advantages; in my testing, the DAE formulation and implicit formulation tend to run faster and more closely reflect the problem structure, but they run into instabilities when the sublimation front peels away from the wall, whereas the explicit ODE formulation can jump over that point.\n\n\n\n\n\n","category":"function"},{"location":"sim/#Setting-Up-for-Simulation","page":"Running a Simulation","title":"Setting Up for Simulation","text":"","category":"section"},{"location":"sim/#LevelSetSublimation.PhysicalProperties","page":"Running a Simulation","title":"LevelSetSublimation.PhysicalProperties","text":"An immutable type for representing a slate of physical properties and constants needed.\n\nA default constructor is provided which uses all defaults (borosilicate glass, water, ice), but thanks to Parameters.jl you can call with just values that need to be changed, e.g.\n\nPhysicalProperties() # all defaults\nPhysicalProperties(ρ_vw = 1u\"kg/m^3\", cp_vw = 1u\"J/kg/K\", εpp_vw = 1e-1) # adjust vial wall properties\n\nAll properties stored here are:\n\nρ_vw: Density of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.ρ_gl\ncp_vw: Heat capacity of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.cp_gl\nεpp_vw: Dielectric loss coefficient of vial wall (defaults to borosilicate glass). Default: LevelSetSublimation.εpp_gl\nρf: Density of frozen material (taken as water ice). Default: ρ_ice\nCpf: Heat capacity of frozen material (taken as water ice). Default: cp_ice\nkf: Thermal conductivity of frozen material. Default: LevelSetSublimation.kf\nMw: Molecular weight of sublimating species (defaults to water). Default: 0.018 * u\"kg/mol\"\nμ: Gas phase viscosity (in rarefied regime) of sublimating species (defaults to water). Default: LevelSetSublimation.μ\nΔH: Heat of sublimation of sublimating species (defaults to water); give as positive number. Default: LevelSetSublimation.ΔH\nεppf: Dielectric loss coefficient of frozen layer (defaults to water ice). Default: LyoPronto.εppf\nεpp_d: Dielectric loss coefficient of dry layer (defaults to 0). Default: 0.0\nR: Universal gas constant. Kept as a constant so that it gets nondimensionalized with the rest. Default: u\"R\"\nϵ0: Vacuum permittivity. Kept as a constant so that it gets nondimensionalized with the rest. Default: u\"ϵ0\" |> u\"F/m\"\n\n\n\n\n\n","category":"type"},{"location":"sim/#LevelSetSublimation.TimeConstantProperties","page":"Running a Simulation","title":"LevelSetSublimation.TimeConstantProperties","text":"TimeConstantProperties(ϵ, l, κ, Rp0, kd, Kvwf, m_v, A_v, B_d, B_f, B_vw)\n\nA struct for holding physical properties which are likely to change from case to case.\n\nNo default constructor is provided by intention–all of these parameters should be at least considered before running a simulation.\n\nϵ\nl\nκ\nRp0\nkd\nKvwf\nm_v\nA_v\nB_d\nB_f\nB_vw\n\n\n\n\n\n","category":"type"},{"location":"sim/#LevelSetSublimation.TimeVaryingProperties","page":"Running a Simulation","title":"LevelSetSublimation.TimeVaryingProperties","text":"TimeVaryingProperties(f_RF, P_per_vial, Tsh, pch, Kshf)\n\nA struct for holding controlled parameters that may change over time.\n\nTo get the value of all those parameters at a given time, call the struct  with a time, and it will evaluate each field at that time and provide a TimeVaryingPropertiesSnapshot. \n\nNo default constructor is provided by intention–all of these parameters should be at least considered before running a simulation.\n\nEach should be passed as a callable, which returns the value of the parameter as a function of time, with the exception of Kshf which is a function of pressure. See the RampedVariable and RpFormFit types from LyoPronto, which are intended to make this more convenient.\n\nf_RF\nP_per_vial\nTsh\npch\nKshf\n\n\n\n\n\n","category":"type"},{"location":"sim/#LevelSetSublimation.TimeVaryingPropertiesSnapshot","page":"Running a Simulation","title":"LevelSetSublimation.TimeVaryingPropertiesSnapshot","text":"TimeVaryingPropertiesSnapshot(f_RF, P_per_vial, Tsh, pch, Kshf)\n\nA struct for holding a snapshot of the controlled parameters that may change over time.\n\nThis is meant to be constructed by calling an instance of the TimeVaryingProperties type.\n\nf_RF\nP_per_vial\nTsh\npch\nKshf\n\n\n\n\n\n","category":"type"},{"location":"sim/","page":"Running a Simulation","title":"Running a Simulation","text":"Here is a sample simulation setup, in a case where nothing complicated is happening.","category":"page"},{"location":"sim/","page":"Running a Simulation","title":"Running a Simulation","text":"# ---- Properties which do not change in time\n\n# Mass transfer\nϵ = 0.95 # 90% porosity\nκ = 0.0u\"m^2\" # ~size^2 of a pore\nRp0 = 1.4u\"cm^2*hr*Torr/g\"\nA1 = 16u\"cm*hr*Torr/g\"\nTguess = 260u\"K\"\nl = sqrt(base_props.R*Tguess/base_props.Mw) / A1\n# Heat transfer\nkd = LSS.k_sucrose * (1-ϵ)\nm_v = LyoPronto.get_vial_mass(vialsize)\nA_v = π*LyoPronto.get_vial_radii(vialsize)[2]^2\n# Microwave\nB_d = 0.0u\"Ω/m^2\"\ntcprops = TimeConstantProperties(ϵ, l_bulk, κ, Rp0, kd, Kvwf, m_v, A_v, B_d, Bf, Bvw)\n\n# Properties which may change in time\nf_RF = RampedVariable(8.0u\"GHz\")\npch = RampedVariable(100.0u\"mTorr\")\nTsh = RampedVariable(uconvert.(u\"K\", [-40.0, 10]*u\"°C\"), 1u\"K/minute\")\nP_per_vial = RampedVariable(10u\"W\"/17)\n# Heat transfer coefficient as function of pressure\nKC = 2.75e-4u\"cal/s/K/cm^2\"\nKP = 8.93e-4u\"cal/s/K/cm^2/Torr\"\nKD = 0.46u\"1/Torr\"\nKshf = RpFormFit(KC, KP, KD)\ntvprops = TimeVaryingProperties(f_RF, P_per_vial, Tsh, pch, Kshf)\n\nparamsd = LSS.base_props, tcprops, tvprops\n\nvialsize = \"6R\"\nfillvol = 5u\"mL\"\nsimgridsize = (41, 31)\n\nconfig = Dict{Symbol, Any}()\n@pack! config = paramsd, vialsize, fillvol, simgridsize","category":"page"},{"location":"sim/#Run-a-simulation","page":"Running a Simulation","title":"Run a simulation","text":"","category":"section"},{"location":"sim/","page":"Running a Simulation","title":"Running a Simulation","text":"res = sim_from_dict(config)","category":"page"},{"location":"sim/#Visualize-and-work-with-simulation-results","page":"Running a Simulation","title":"Visualize and work with simulation results","text":"","category":"section"},{"location":"sim/#The-Guts-(not-exported)","page":"Running a Simulation","title":"The Guts (not exported)","text":"","category":"section"},{"location":"sim/#Heat-transfer-only-simulation:-OUTDATED","page":"Running a Simulation","title":"Heat-transfer-only simulation: OUTDATED","text":"","category":"section"},{"location":"sim/#LevelSetSublimation.sim_heatonly","page":"Running a Simulation","title":"LevelSetSublimation.sim_heatonly","text":"sim_heatonly(config; tf=1e5, verbose=false)\n\nGiven a simulation configuration config, run a simulation.\n\nThis simulation is stripped-down: no mass transfer, no variation in ice & glass temperature\n\nMaximum simulation time is specified by tf. verbose=true will put out some info messages about simulation progress, i.e. at each reinitialization.\n\nCURRENTLY OUT OF DATE with parameter input structures.\n\n\n\n\n\n","category":"function"},{"location":"sim/#LevelSetSublimation.dudt_heatonly","page":"Running a Simulation","title":"LevelSetSublimation.dudt_heatonly","text":"dudt_heatonly(u, dom::Domain, params)\ndudt_heatonly(u, config)\n\nCompute the time derivative of u with given parameters.\n\nWraps a call on dudt_heatonly!, for convenience in debugging and elsewhere that efficiency is less important\n\n\n\n\n\n","category":"function"},{"location":"sim/#LevelSetSublimation.dudt_heatonly!","page":"Running a Simulation","title":"LevelSetSublimation.dudt_heatonly!","text":"dudt_heatonly!(du, u, p, t)\n\nEvaluate local time rate of change for u and put results in du.\n\nThis function leaves Tf and Tvw untouched, since there isn't a way to govern their dynamics without mass transfer.\n\nu and du are both structured according to \n\nThis is a right-hand-side for ∂ₜϕ = -v⋅∇ϕ, where v = (vr, vz) is evaluated by computing and extrapolating front velocity using compute_frontvel_mass.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#Solving-steady-state-heat-equation","page":"Solving Physical Equations","title":"Solving steady-state heat equation","text":"","category":"section"},{"location":"heatmass/","page":"Solving Physical Equations","title":"Solving Physical Equations","text":"TODO: fill this out","category":"page"},{"location":"heatmass/#Physical-Equation-Solution","page":"Solving Physical Equations","title":"Physical Equation Solution","text":"","category":"section"},{"location":"heatmass/#LevelSetSublimation.solve_T","page":"Solving Physical Equations","title":"LevelSetSublimation.solve_T","text":"solve_T(u, Tf, dom::Domain, params)\n\nCompute 2D axisymmetric T profile, returning ghost cell values, for given state u and Tf.\n\nNeumann boundary conditions on all rectangular boundaries; Dirichlet on zero-level set.\n\nThis implementation uses second-order finite differences, with linear extrapolation into Ω⁻.   Coefficients are all hard-coded here, unfortunately. (For more on extrapolation, see Gibou et al., 2002, \"Second-Order-Accurate ... Poisson ... \")   Neumann boundaries use a ghost point & BC to define ghost cell, then use same stencil as normal. Coefficients computed in gfm_extrap.ipynb, using Sympy.   (For higher order, see Gibou and Fedkiw, 2005, \"A fourth order accurate discretization ... Laplace ... \")  \n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.solve_p","page":"Solving Physical Equations","title":"LevelSetSublimation.solve_p","text":"solve_p(u, T, dom::Domain, params[, p0]; maxit=20, reltol=1e-6) where G<:AbstractArray\n\nIteratively compute the pressure profile for system state u, Tf, and T.\n\nThere is a weak nonlinearity in the system, since the mass transfer coefficient b depends partially on pressure. To treat this, use a guessed pressure p0 (which, if not provided, is set everywhere to chamber pressure) to compute b, then perform a linear solve for p using solve_p_given_b. At this point, recompute b, then recompute p.\n\nIn preliminary testing, this usually converges within 5 or 10 iterations. Usually if it doesn't converge, it is because temperatures are outside the expected range, yielding crazy sublimation pressures. (Occasionally it means I incorrectly wrote a finite difference somewhere.)\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.solve_p_given_b","page":"Solving Physical Equations","title":"LevelSetSublimation.solve_p_given_b","text":"solve_p_given_b(ϕ, b, Tf, dom::Domain, params)\n\nCompute 2D axisymmetric pseudosteady pressure profile for given values of level set function ϕ, temperature T, and transport coefficient b.\n\nb is a dusty-gas transport coefficient for the pressure, which can vary spatially. Homogeneous Neumann boundary conditions at r=0, r=R, z=0; Dirichlet on zero-level set (p=p_sub), Robin at top (dp/dz = (pch-p)/Rp0). params should have fields: \n\nRp0 : zero-thickness resistance offset, often written R0 in lyo literature\npch : chamber (or vial) pressure at top surface\n\nThis implementation uses second-order finite differences, with linear extrapolation into Ω⁻.   (For details, see (Gibou and Fedkiw, 2005).)   Coefficients are all hard-coded here, unfortunately. Neumann boundaries use a ghost point & BC to define ghost cell, then use same stencil as normal. Coefficients computed in gfm_extrap.ipynb, using Sympy.  \n\n\n\n\n\n","category":"function"},{"location":"heatmass/#Lumped-computations","page":"Solving Physical Equations","title":"Lumped computations","text":"","category":"section"},{"location":"heatmass/#LevelSetSublimation.compute_Qice","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_Qice","text":"function compute_Qice(ϕ, T, p, dom::Domain, params)\n\nCompute the total heat input into frozen & dried domains. Also passes glass-ice heat as separate return.\n\nSee p. 112-113 from paperlike notes. At pseudosteady conditions, all heat getting added to the system goes to the frozen domain, so we don't actually need to treat different areas of the surface. In addition, the sublimation flux is simply evaluated at the top cake surface.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_topmassflux","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_topmassflux","text":"compute_topmassflux(ϕ, T, p, dom::Domain, params)\n\nCompute total mass flow through top of the cake (that is, mass flux integrated across top surface).\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_Qice_noflow","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_Qice_noflow","text":"compute_Qice_noflow(u, T, dom::Domain, params)\n\nCompute the total heat input into frozen & dried domains, assuming mass flow is zero. Also passes glass-ice heat as separate return.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_Qice_nodry","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_Qice_nodry","text":"compute_Qice_nodry(u, T, dom::Domain, params)\n\nCompute the total heat input into frozen domain from volumetric, shelf, and glass.  Contrast with compute_Qice_noflow and compute_Qice, which include heat to dried domain.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#Computing-velocity:-coupling-solutions-to-level-set-motion","page":"Solving Physical Equations","title":"Computing velocity: coupling solutions to level set motion","text":"","category":"section"},{"location":"heatmass/#LevelSetSublimation.compute_frontvel_mass","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_frontvel_mass","text":"compute_frontvel_mass(ϕ, Tf, T, p, dom::Domain, params; debug=false)\n\nGenerate an empty velocity field and compute velocity on Γ⁺ (i.e. cells on Γ with ϕ>0). \n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_frontvel_heat","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_frontvel_heat","text":"compute_frontvel_heat(u, T, p, dom::Domain, params; debug=false)\n\nGenerate an empty velocity field and compute velocity on Γ⁺ (i.e. cells on Γ with ϕ>0). \n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_frontvel_fixedspeed","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_frontvel_fixedspeed","text":"compute_frontvel_fixedspeed(v0, ϕ, dom::Domain)\n\nCompute speed v0 times normal vector on Γ⁺, positive side of interface.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#Geometric-computations-from-level-set","page":"Solving Physical Equations","title":"Geometric computations from level set","text":"","category":"section"},{"location":"heatmass/#LevelSetSublimation.compute_icesh_area","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_icesh_area","text":"compute_icesh_area(ϕ, dom::Domain)\n\nCompute area of where ice meets bottom surface of vial.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/#LevelSetSublimation.compute_icegl_area","page":"Solving Physical Equations","title":"LevelSetSublimation.compute_icegl_area","text":"compute_icegl_area(ϕ, dom::Domain)\n\nCompute area of where ice meets radial outer surface of vial.\n\n\n\n\n\n","category":"function"},{"location":"heatmass/","page":"Solving Physical Equations","title":"Solving Physical Equations","text":"See also compute_icevol_H and compute_icesurf_δ.","category":"page"},{"location":"#LevelSetSublimation-Documentation","page":"Table of Contents","title":"LevelSetSublimation Documentation","text":"","category":"section"},{"location":"#Table-of-Contents","page":"Table of Contents","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"Pages = [\"sim.md\", \"plots.md\", \"eqs.md\", \"heatmass.md\", \"levelset.md\", \"disc.md\", \"alldocs.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Table of Contents","title":"Table of Contents","text":"In the side bar, you can also find a page with referenced journal articles. (That doesn't play nice with this table of contents, but it's there.)","category":"page"},{"location":"levelset/#Details-on-the-Level-Set-Method","page":"Level Set","title":"Details on the Level Set Method","text":"","category":"section"},{"location":"levelset/","page":"Level Set","title":"Level Set","text":"TODO: fill this out","category":"page"},{"location":"levelset/#Main-Level-Set-Tools","page":"Level Set","title":"Main Level Set Tools","text":"","category":"section"},{"location":"levelset/#LevelSetSublimation.reinitialize_ϕ_HCR!","page":"Level Set","title":"LevelSetSublimation.reinitialize_ϕ_HCR!","text":"reinitialize_ϕ_HCR!(ϕ, dom::Domain; maxsteps = 50, tol=1e-4, err_reg=:B)\n\nReinitialize ϕ throughout the domain.\n\nImplementation of Eq. 22 in Hartmann 2010, scheme HCR-2.\n\nChecks L∞ error (of |∇ϕ|=1) against tol either in band around interface  (err_reg=:B) or throughout domain (err_reg=:all), and ends iteration  early if tolerance is met.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.reinitialize_ϕ_HCR","page":"Level Set","title":"LevelSetSublimation.reinitialize_ϕ_HCR","text":"reinitialize_ϕ_HCR(ϕ, dom::Domain)\n\nThin wrapper on reinitialize_ϕ_HCR! to avoid mutating.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.extrap_v_fastmarch!","page":"Level Set","title":"LevelSetSublimation.extrap_v_fastmarch!","text":"extrap_v_fastmarch(v_front, u, dom::Domain)\n\nCompute an extrapolated velocity field in place. v_front should be nonzero only on Γ⁺, positive side of interface.\n\nUsing fast marching, instead of the PDE-based approach, to get second order accuracy more easily.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#Discretizations,-Backend","page":"Level Set","title":"Discretizations, Backend","text":"","category":"section"},{"location":"levelset/#LevelSetSublimation.identify_Γ","page":"Level Set","title":"LevelSetSublimation.identify_Γ","text":"function identify_Γ(ϕ, dom::Domain)\n\nIdentify cells on the sublimation front (interface), returning as a Matrix::Bool.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.Γ_cells","page":"Level Set","title":"LevelSetSublimation.Γ_cells","text":"Γ_cells(ϕ, dom::Domain)\n\nCompute findall(identify_Γ(ϕ, dom)). (That's the whole implementation.)\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.𝒢_weno","page":"Level Set","title":"LevelSetSublimation.𝒢_weno","text":"𝒢_weno(ϕ, ir::Int, iz::Int, dom::Domain)\n𝒢_weno(ϕ, ind::CartesianIndex{2}, dom::Domain)\n𝒢_weno(ϕ, ir::Int, iz::Int, ϕ0sign, dom::Domain)\n𝒢_weno(ϕ, ind::CartesianIndex{2}, ϕ0sign, dom::Domain)\n\nCompute the norm of the gradient by Godunov's scheme with WENO differences (wenodiffs_local).\n\nIf supplied, ϕ0sign is used in Godunov's scheme, rather than the current sign of ϕ. Described in (Hartmann et al., 2009), eq. 6 to eq. 9. Boundary treatment of ghost cells handled by get_or_extrapolate_ϕ.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.𝒢_weno_all","page":"Level Set","title":"LevelSetSublimation.𝒢_weno_all","text":"𝒢_weno_all(ϕ, [dϕdx_all,] dom::Domain; signs=nothing)\n\nCompute the norm of the gradient of ϕ throughout domain by Godunov's scheme with WENO derivatives. If signs of ϕ should refer to some prior state, can be provided. If dϕdx_all is provided, then is not recomputed internally.\n\nInternally, calls 𝒢_weno on all computational cells.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.dϕdx_all_WENO","page":"Level Set","title":"LevelSetSublimation.dϕdx_all_WENO","text":"dϕdx_all_WENO(ϕ, dom)\n\nCompute (∂ϕ/∂r west, ∂ϕ/∂r east, ∂ϕ/∂z south, ∂ϕ/∂z north) using WENO derivatives.\n\nImplemented by computing WENO derivatives for each cell separately, which is a little wasteful. Beyond the boundaries of domain, ϕ is extrapolated according to get_or_extrapolate_ϕ.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.wenodiffs_local","page":"Level Set","title":"LevelSetSublimation.wenodiffs_local","text":"wenodiffs_local(u_m3, u_m2, u_m1, u_0, u_p1, u_p2, u_p3, dx)\n\nCompute one-sided finite differences, using Jiang and Peng's WENO approximation (Jiang and Peng, 2000).\n\nA relatively easy-to-read reference is §3.2 of (Hartmann et al., 2009) .\n\n\n\n\n\n","category":"function"},{"location":"levelset/#Error-evaluation","page":"Level Set","title":"Error evaluation","text":"","category":"section"},{"location":"levelset/#LevelSetSublimation.identify_B","page":"Level Set","title":"LevelSetSublimation.identify_B","text":"identify_B(Γc::Vector{CartesianIndex{2}}, dom::Domain; extra=0)\nidentify_B(Γ_field::Matrix{Bool}, dom::Domain)\nidentify_B(ϕ::Matrix{Float64}, dom::Domain)\nidentify_B(ϕ::Any, dom::Domain)\n\nReturn a field of bools identifying the band around the interface.\n\nThe width in the band around Γ is specified by the fields bwr and bwz,  which represent number of cells in the 𝑟 and 𝑧 directions respectively. extra will tack on extra cells, if in some (but not all) places you need a larger band than the default.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.sdf_err_L1","page":"Level Set","title":"LevelSetSublimation.sdf_err_L1","text":"sdf_err_L1(ϕ, dom; region=:B)\n\nCompute the L1 norm of the error in the Eikonal equation  |∇ϕ| = 1, on the given region (either :B or :all).\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.sdf_err_L∞","page":"Level Set","title":"LevelSetSublimation.sdf_err_L∞","text":"sdf_err_L∞(ϕ, dom; region=:B)\n\nCompute the L∞ norm of the error in the Eikonal equation  |∇ϕ| = 1, on the given region (either :B or :all).\n\n\n\n\n\n","category":"function"},{"location":"levelset/#Volume-and-surface-integrals-and-evaluations","page":"Level Set","title":"Volume and surface integrals and evaluations","text":"","category":"section"},{"location":"levelset/#LevelSetSublimation.compute_icevol_H","page":"Level Set","title":"LevelSetSublimation.compute_icevol_H","text":"compute_icevol_H(ϕ, dom)\n\nCompute the volume of the ice, using a discrete Heaviside function. Calls compute_discrete_H, which is implemented according to Min and Gibou 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.compute_discrete_H","page":"Level Set","title":"LevelSetSublimation.compute_discrete_H","text":"compute_discrete_H(ϕ, dom)\n\nCompute the discrete Heaviside H across the domain, for use in volume integrals. \n\nImplements the discrete Heaviside of Min & Gibou, 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.compute_local_H","page":"Level Set","title":"LevelSetSublimation.compute_local_H","text":"compute_local_H(ij::CartesianIndex, ϕ, dom)\n\nReturn the discrete Heaviside for level set ϕ at location ij.\n\nImplementation of the final expression for a discrete Heaviside in Min & Gibou, 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.compute_icesurf_δ","page":"Level Set","title":"LevelSetSublimation.compute_icesurf_δ","text":"compute_icesurf_δ(ϕ, dom)\n\nCompute the surface area of the ice, using a discrete Dirac delta function. Calls compute_discrete_δ, which is implemented according to Min and Gibou 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.compute_discrete_δ","page":"Level Set","title":"LevelSetSublimation.compute_discrete_δ","text":"compute_discrete_δ(ϕ, dom)\n\nCompute the discrete Dirac δ throughout the domain, for use in surface integrals.  Implements the discrete delta of Min and Gibou 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#LevelSetSublimation.compute_local_δ","page":"Level Set","title":"LevelSetSublimation.compute_local_δ","text":"compute_local_δ(ij::CartesianIndex, ϕ, dom)\n\nReturn the discrete delta for level set ϕ at location ij.\n\nImplementation of the final expression for a discrete delta in Min and Gibou 2008.\n\n\n\n\n\n","category":"function"},{"location":"levelset/#Initial-sublimation-front-shapes,-for-numerical-testing","page":"Level Set","title":"Initial sublimation front shapes, for numerical testing","text":"","category":"section"},{"location":"levelset/#LevelSetSublimation.make_ϕ0","page":"Level Set","title":"LevelSetSublimation.make_ϕ0","text":"make_ϕ0(ϕtype::Symbol, dom::Domain; ϵ=1e-4)\n\nReturn a ϕ0 with appropriate size for the passed Domain.\n\nParameter ϵ * sqrt(dom.rmax*dom.zmax) is added to ensure that interface is within domain. Currently allowed setups:\n\n:top, :flat – interface at zmax*(1 - ϵ)\n:rad, :cyl  – interface at rmax*(1 - ϵ)\n:box          – interface at both zmax(1-ϵ) and rmax(1-ϵ)\n:cone         – interface a line decreasing in r\n:midflat      – interface at zmax*0.5\n:ell_bub     – ellipse in center of vial, separated from boundaries\n:circ        – circle at r=0, z=0 \n:tinycirc    – circle at r=0, z=0, very small radius\n\n\n\n\n\n","category":"function"},{"location":"refs/#References","page":"References","title":"References","text":"","category":"section"},{"location":"refs/","page":"References","title":"References","text":"Gibou, F. and Fedkiw, R. (2005). A Fourth Order Accurate Discretization for the Laplace and Heat Equations on Arbitrary Domains, with Applications to the Stefan Problem. Journal of Computational Physics 202, 577–601.\n\n\n\nHartmann, D.; Meinke, M. and Schröder, W. (2009). On Accuracy and Efficiency of Constrained Reinitialization. International Journal for Numerical Methods in Fluids, n/a-n/a.\n\n\n\nHartmann, D.; Meinke, M. and Schröder, W. (2010). The Constrained Reinitialization Equation for Level Set Methods. Journal of Computational Physics 229, 1514–1535.\n\n\n\nJiang, G.-S. and Peng, D. (2000). Weighted ENO Schemes for Hamilton–Jacobi Equations. SIAM Journal on Scientific Computing 21, 2126–2143.\n\n\n\nMin, C. and Gibou, F. (2008). Robust second-order accurate discretizations of the multi-dimensional Heaviside and Dirac delta functions. Journal of Computational Physics 227, 9686–9695. Accessed on Jun 29, 2023.\n\n\n\nSethian, J. A. (1999). Fast Marching Methods. SIAM Review 41, 199–235.\n\n\n\n","category":"page"}]
}
